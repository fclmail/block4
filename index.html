<!DOCTYPE html>
<html>
<head>
  <title>Atomic Arbitrage Scanner</title>
  <script src="https://cdn.ethers.io/lib/ethers-5.2.umd.min.js"></script>
  <style>
    body {
      background-color: #003300;
      color: #ccffcc;
      font-family: monospace;
      padding: 20px;
    }
    textarea {
      width: 100%;
      height: 200px;
      background: #001a00;
      color: #ccffcc;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <h2>Atomic Arbitrage Simulator</h2>
  <label>Trade Amount (USDC): <input type="number" id="amount" value="10"></label><br>
  <label>Minimum Profit (USDC): <input type="number" id="minProfit" value="0.1"></label><br>
  <label>Slippage %: <input type="number" id="slippage" value="0.05"></label><br>
  <div>Wallet USDC Balance: <span id="balance">0</span> USDC</div>
  <button onclick="startScan()">Start Scanning</button>
  <textarea id="log"></textarea>
  <script>
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    let signer;
    let contract;

    const contractAddress = "0x98BD86aDa64DC52E60392a43050fad5E9cAcb62F"; // Replace with deployed contract
    const contractAbi = [
	{
		"inputs": [],
		"stateMutability": "nonpayable",
		"type": "constructor"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "address",
				"name": "tokenIn",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "address",
				"name": "tokenOut",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "inputAmount",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "outputAmount",
				"type": "uint256"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "profit",
				"type": "uint256"
			}
		],
		"name": "ArbitrageExecuted",
		"type": "event"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "router1",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "router2",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "tokenIn",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "tokenOut",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "amountIn",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "minProfit",
				"type": "uint256"
			}
		],
		"name": "executeArbitrage",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "token",
				"type": "address"
			}
		],
		"name": "withdrawToken",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "owner",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	}
];

    const routers = {
      quickswap: "0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff",
      sushiswap: "0x1b02da8cb0d097eb8d57a175b88c7d8b47997506",
      dfyn: "0xA102072A4C07F06EC3B4900FDC4C7B80b6c57429"
    };

    const tokens = {
      usdc: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
      dai: "0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063",
      weth: "0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619",
      wbtc: "0x1BFD67037B42Cf73acF2047067bd4F2C47D9BfD6",
      aave: "0xD6DF932A45C0f255f85145f286eA0b292B21C90B"
    };

    async function updateBalance() {
      const usdc = new ethers.Contract(tokens.usdc, ["function balanceOf(address) view returns (uint256)"], provider);
      const address = await signer.getAddress();
      const balance = await usdc.balanceOf(address);
      document.getElementById("balance").textContent = ethers.utils.formatUnits(balance, 6);
    }

    async function startScan() {
      await provider.send("eth_requestAccounts", []);
      signer = provider.getSigner();
      contract = new ethers.Contract(contractAddress, contractAbi, signer);
      updateBalance();

      setInterval(async () => {
        updateBalance();
        const amountIn = ethers.utils.parseUnits(document.getElementById("amount").value, 6);
        const minProfit = ethers.utils.parseUnits(document.getElementById("minProfit").value, 6);

        for (const tokenSymbol of ["dai", "weth", "wbtc", "aave"]) {
          for (const router1 of Object.values(routers)) {
            for (const router2 of Object.values(routers)) {
              if (router1 === router2) continue;
              const tokenOut = tokens[tokenSymbol];
              const tokenIn = tokens["usdc"];

              try {
                const amountsOut1 = await new ethers.Contract(router1, ["function getAmountsOut(uint, address[]) view returns (uint[] memory)"] , provider).getAmountsOut(amountIn, [tokenIn, tokenOut]);
                const tokenAmount = amountsOut1[1];

                const amountsOut2 = await new ethers.Contract(router2, ["function getAmountsOut(uint, address[]) view returns (uint[] memory)"] , provider).getAmountsOut(tokenAmount, [tokenOut, tokenIn]);

                const finalAmount = amountsOut2[1];
                const profit = finalAmount.sub(amountIn);

                log(`Checking ${tokenSymbol.toUpperCase()} via ${router1.slice(0,6)} ‚Üí ${router2.slice(0,6)} | Est. Profit: ${ethers.utils.formatUnits(profit, 6)} USDC`);

                if (profit.gt(minProfit)) {
                  log(`üöÄ Executing arbitrage for ${tokenSymbol.toUpperCase()}...`);
                  const tx = await contract.executeArbitrage(router1, router2, tokenIn, tokenOut, amountIn, minProfit);
                  const receipt = await tx.wait();
                  log(`‚úÖ Success! Tx: ${receipt.transactionHash}`);
                  updateBalance();
                }
              } catch (e) {
                log(`‚ö†Ô∏è Error: ${e.message}`);
              }
            }
          }
        }
      }, 10000);
    }

    function log(msg) {
      const logBox = document.getElementById("log");
      logBox.value += `[${new Date().toLocaleTimeString()}] ${msg}\n`;
      logBox.scrollTop = logBox.scrollHeight;
    }
  </script>
</body>
</html>
